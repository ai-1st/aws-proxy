worker_processes auto;
error_log logs/error.log info;

events {
    worker_connections 1024;
}

# Stream module for handling CONNECT requests
stream {
    # Define an upstream for AWS services
    upstream aws_services {
        server sts.amazonaws.com:443;
        server sts.us-east-1.amazonaws.com:443;
        # Add other AWS service endpoints as needed
    }
    
    # SSL server that will decrypt and re-encrypt traffic
    server {
        listen 8443 ssl;
        
        # SSL certificate for the proxy
        ssl_certificate /etc/nginx/ssl/aws-proxy.pem;
        ssl_certificate_key /etc/nginx/ssl/aws-proxy.pem;
        
        # SSL settings
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';
        
        # Proxy to AWS services
        proxy_pass aws_services;
        proxy_ssl on;
        proxy_ssl_server_name on;
    }
}

http {
    lua_shared_dict aws_keys 10m;  # Shared memory for storing access keys and roles
    
    # Add resolver for DNS resolution
    resolver 8.8.8.8 8.8.4.4 ipv6=off;
    
    init_by_lua_block {
        -- Initialize the LRU cache for access keys
        local lrucache = require "resty.lrucache"
        -- Create a cache that can store up to 1000 items
        local cache, err = lrucache.new(1000)
        if not cache then
            ngx.log(ngx.ERR, "Failed to create LRU cache: ", err)
            return
        end
        -- Store the cache in a global variable for access across requests
        _G.access_key_cache = cache
    }

    # HTTP server for redirecting to HTTPS
    server {
        listen 80;
        server_name localhost;
        
        # Redirect all HTTP traffic to HTTPS
        location / {
            return 301 https://$host$request_uri;
        }
    }

    # HTTPS server for handling AWS API requests
    server {
        listen 443 ssl;
        server_name localhost;
        
        # SSL certificate
        ssl_certificate /etc/nginx/ssl/aws-proxy.pem;
        ssl_certificate_key /etc/nginx/ssl/aws-proxy.pem;
        
        # SSL settings
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';
        
        # Handle CONNECT requests
        error_page 400 = @handle_connect;
        
        location @handle_connect {
            # Redirect CONNECT requests to our stream module
            return 301 https://localhost:8443;
        }
        
        # Proxy all requests to AWS
        location / {
            # AWS service handler
            access_by_lua_block {
                -- Get the Authorization header
                local auth_header = ngx.req.get_headers()["Authorization"]
                
                -- Check if the authorization header exists
                if not auth_header then
                    ngx.log(ngx.ERR, "No Authorization header found")
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                
                -- Extract access key from Authorization header
                local access_key = nil
                if auth_header then
                    -- Format: AWS4-HMAC-SHA256 Credential=ACCESS_KEY_ID/DATE/REGION/SERVICE/aws4_request, ...
                    local match = ngx.re.match(auth_header, "Credential=([A-Z0-9]+)/", "jo")
                    if match then
                        access_key = match[1]
                        ngx.log(ngx.INFO, "Found access key: ", access_key)
                    end
                end
                
                -- Read request body if needed for checking if this is a GetCallerIdentity request
                ngx.req.read_body()
                local req_body = ngx.req.get_body_data() or ""
                
                -- Check if this is a GetCallerIdentity request (always allowed)
                local is_get_caller_identity = false
                if req_body and string.find(req_body, "Action=GetCallerIdentity") then
                    is_get_caller_identity = true
                    ngx.log(ngx.INFO, "GetCallerIdentity request detected, allowing")
                end
                
                -- Check if access key is already known (in the LRU cache)
                local is_known_key = false
                if access_key then
                    is_known_key = _G.access_key_cache:get(access_key) ~= nil
                    if is_known_key then
                        ngx.log(ngx.INFO, "Known access key detected, allowing: ", access_key)
                    end
                end
                
                -- If it is neither a GetCallerIdentity request nor a known access key, deny access
                if not is_get_caller_identity and not is_known_key then
                    ngx.log(ngx.ERR, "Access denied for unknown access key")
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end
                
                -- Store the access key and request body in the current request context for use in body_filter
                ngx.ctx.access_key = access_key
                ngx.ctx.req_body = req_body
            }
            
            # Parse the response to extract IAM roles and access keys
            body_filter_by_lua_block {
                -- Get the request info from context
                local access_key = ngx.ctx.access_key
                local req_body = ngx.ctx.req_body or ""
                
                -- Initialize buffered_response if it doesn't exist
                if not ngx.ctx.buffered_response then
                    ngx.ctx.buffered_response = ""
                end
                
                -- Only process complete responses
                if not ngx.arg[2] then  -- The response is not complete yet
                    -- Append the current chunk to the partial response
                    ngx.ctx.buffered_response = ngx.ctx.buffered_response .. (ngx.arg[1] or "")
                    return
                end
                
                -- Get the complete response body
                local resp_body = ngx.ctx.buffered_response .. (ngx.arg[1] or "")
                
                -- Only parse responses if we have an access key
                if not access_key then
                    return
                end
                
                local new_access_key = nil
                local role_arn = nil
                
                -- Check if this is an AssumeRole response
                if string.find(req_body, "Action=AssumeRole") and string.find(resp_body, "<AssumeRoleResponse") then
                    -- Extract the role ARN from the request
                    local role_match = ngx.re.match(req_body, "RoleArn=([^&]+)", "jo")
                    if role_match then
                        -- URL decode the role ARN
                        role_arn = role_match[1]:gsub("%%3A", ":"):gsub("%%2F", "/")
                        ngx.log(ngx.INFO, "Extracted role ARN from AssumeRole request: ", role_arn)
                    end
                    
                    -- Extract the new access key from the response
                    local key_match = ngx.re.match(resp_body, "<AccessKeyId>([A-Z0-9]+)</AccessKeyId>", "jo")
                    if key_match then
                        new_access_key = key_match[1]
                        ngx.log(ngx.INFO, "Extracted new access key from AssumeRole response: ", new_access_key)
                    end
                    
                    -- Store the new access key in the cache if found along with role
                    if new_access_key and role_arn then
                        _G.access_key_cache:set(new_access_key, role_arn)
                        ngx.log(ngx.INFO, "Added new access key to cache: ", new_access_key, " for role: ", role_arn)
                    end
                    
                -- Check if this is a GetCallerIdentity response
                elseif string.find(req_body, "Action=GetCallerIdentity") and string.find(resp_body, "<GetCallerIdentityResponse") then
                    -- Extract the role ARN from the response
                    local role_match = ngx.re.match(resp_body, "<Arn>arn:aws:sts::(\\d+):assumed-role/([^/]+)/([^<]+)</Arn>", "jo")
                    if role_match then
                        local account_id, role_name = role_match[1], role_match[2]
                        -- Reconstruct the full role ARN
                        role_arn = "arn:aws:iam::" .. account_id .. ":role/" .. role_name
                        ngx.log(ngx.INFO, "Extracted role ARN from GetCallerIdentity response: ", role_arn)
                    else
                        -- If it is not an assumed role, it might be a user or other entity
                        local arn_match = ngx.re.match(resp_body, "<Arn>([^<]+)</Arn>", "jo")
                        if arn_match then
                            role_arn = arn_match[1]
                            ngx.log(ngx.INFO, "Extracted ARN from GetCallerIdentity response: ", role_arn)
                        end
                    end
                    
                    -- Store the access key in the cache if we have a role ARN
                    if role_arn and access_key then
                        _G.access_key_cache:set(access_key, role_arn)
                        ngx.log(ngx.INFO, "Added access key to cache: ", access_key, " for role: ", role_arn)
                    end
                end
            }
            
            # Proxy settings
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass https://$host;  # Forward to whatever AWS service is requested via Host header
            proxy_buffering on;  # Enable buffering for body_filter to work properly
            
            # SSL for backend connections
            proxy_ssl_server_name on;
        }
    }
}
